正则表达匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。



如果是dp[][] 二维矩阵解决该问题的话
考虑从后往前推
因为
'*' 匹配零个或多个前面的那一个元素

m := len(s)
n := len(p)

dp[m][n] = true

for i := m; i >= 0; i-- {
    for j := n - 1; j >= 0; j-- {
        // i, j 的字面匹配
        firstMatch := i < m && (s[i] == p[j] || p[j] == '.')
        // 更新dp[i][j]
        if j < n-1 && p[j+1] == '*' {
            dp[i][j] = (firstMatch && (dp[i+1][j] || dp[i][j+2])) || (!firstMatch && dp[i][j+2])
        } else {
            dp[i][j] = firstMatch && dp[i+1][j+1]
        }
    }
}

从后往前推

效率上肯定是要比递归求解是要高效率的



